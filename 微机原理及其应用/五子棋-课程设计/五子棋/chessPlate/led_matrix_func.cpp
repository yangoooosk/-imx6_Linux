#include "led_matrix_func.h"
#include <stdio.h>
#include <fcntl.h>
#include <sys/types.h>
#include <unistd.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <sys/select.h>
#include <QDebug>
#include <QTextCodec>

// 静态存储字库数据
static struct typFNT_GB16 {
    char Index[7];
    char Msk[32];
} GB_16[] = {
    "",   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

    "恭", 0x04,0x00,0x04,0x20,0x22,0x24,0x19,0x24,0x00,0xA4,0x40,0x7F,0x80,0x24,0x7F,0x24,
    0x00,0x24,0x08,0x7F,0x30,0xA4,0x09,0x24,0x32,0x24,0x04,0x24,0x04,0x20,0x00,0x00,

    "喜", 0x02,0x00,0x02,0x02,0x02,0x0A,0x7A,0xEA,0x4A,0xAA,0x4B,0xAA,0x4A,0xAA,0x4A,0xAF,
    0x4A,0xAA,0x4B,0xAA,0x4A,0xAA,0x7A,0xEA,0x02,0x0A,0x02,0x02,0x02,0x00,0x00,0x00,

    "发", 0x40,0x00,0x20,0x10,0x10,0x3E,0x88,0x10,0x87,0x10,0x41,0xF0,0x46,0x9F,0x28,0x90,
    0x10,0x90,0x28,0x92,0x27,0x94,0x40,0x1C,0xC0,0x10,0x40,0x10,0x00,0x10,0x00,0x00,

    "财", 0x80,0x00,0x43,0xFE,0x20,0x02,0x18,0x02,0x07,0xFA,0x08,0x02,0x73,0xFE,0x20,0x00,
    0x08,0x10,0x06,0x10,0x41,0x90,0x80,0x70,0x7F,0xFF,0x00,0x10,0x00,0x10,0x00,0x00,

    "黑",0x88,0x00,0x68,0x00,0x09,0x3E,0x09,0x22,0x29,0x2A,0xC9,0x32,0x09,0x22,0x0F,0xFE,
    0x29,0x22,0xC9,0x32,0x09,0x2A,0x09,0x22,0x29,0x3E,0xC8,0x00,0x08,0x00,0x00,0x00,

    "白",0x00,0x00,0x00,0x00,0xFF,0xF8,0x41,0x08,0x41,0x08,0x41,0x0C,0x41,0x0A,0x41,0x09,
    0x41,0x08,0x41,0x08,0x41,0x08,0x41,0x08,0xFF,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,

    "棋",0x04,0x10,0x03,0x10,0x00,0xD0,0xFF,0xFF,0x00,0x90,0x09,0x10,0x88,0x04,0x4F,0xFF,
    0x29,0x24,0x09,0x24,0x09,0x24,0x29,0x24,0x4F,0xFF,0x88,0x04,0x08,0x00,0x00,0x00,

    "",   0x03,0x00,0x0E,0x80,0x18,0x00,0x17,0xFE,0x2F,0xFE,0x6F,0xFE,0xF0,0x00,0xF8,0x08,
    0xFD,0xDE,0x7E,0xEA,0x3F,0x76,0x1F,0xBE,0x00,0xC0,0x00,0x62,0x00,0x34,0x00,0x18
};
static int gb16_size = sizeof(GB_16) / sizeof(GB_16[0]);

// 查找字符对应的字模数据
static struct typFNT_GB16* findCharacter(const QString &ch)
{
    // 直接使用 UTF-8 编码进行比较
    QByteArray chUtf8 = ch.toUtf8();
    // 确保每个字符为3个字节
    if (chUtf8.size() != 3) return nullptr;

    for (int i = 0; i < gb16_size; i++) {
        if (GB_16[i].Index[0] == 0) continue; // Skip empty entries

        // 直接比较 UTF-8 编码
        if (GB_16[i].Index[0] == chUtf8[0] &&
            GB_16[i].Index[1] == chUtf8[1] &&
            GB_16[i].Index[2] == chUtf8[2])
             {
            return &GB_16[i];
        }
    }
    return nullptr;
}

void displayLedMatrix(const QString &text)
{
    int mem_fd;
    unsigned short *cpld;

    mem_fd = open("/dev/mem", O_RDWR);
    if (mem_fd < 0) {
        perror("open");
        return ;
    }

    cpld = (unsigned short*)mmap(NULL, (size_t)0x20, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED, mem_fd, (off_t)(0x8000000));
    if (cpld == MAP_FAILED) {
        perror("mmap");
        close(mem_fd);
        return ;
    }

    QStringList characters = text.split("", QString::SkipEmptyParts);
    int charCount = characters.size();

    for (int z = 0; z < charCount; z++) {
      for (int j = 0; j < 16; j++) {
        for (int i = 0; i < 16; i++) {
          typFNT_GB16 *charData1 = findCharacter(characters[z]);
          typFNT_GB16 *charData2 =
              (z + 1 < charCount) ? findCharacter(characters[z + 1]) : nullptr;

          if (charData1) {
            if (i < 16 - j)
              *(cpld + ((0xc0 + i) << 1)) =
                  ((charData1->Msk[(i + j) * 2] << 8) +
                   (charData1->Msk[(i + j) * 2 + 1])); // 数码管
            else if (charData2)
              *(cpld + ((0xc0 + i) << 1)) =
                  ((charData2->Msk[(i - (16 - j)) * 2] << 8) +
                   (charData2->Msk[(i - (16 - j)) * 2 + 1])); // 数码管
          }
        }
        usleep(200000);
      }
      //z++;
    }


    munmap(cpld, 0x20);
    close(mem_fd);
}
