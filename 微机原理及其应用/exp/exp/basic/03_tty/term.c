#include <termios.h>#include <stdio.h>#include <termios.h>#include <stdio.h>#include <unistd.h>#include <stdlib.h>#include <fcntl.h>#include <sys/types.h>#include <string.h>#include <sys/signal.h>#include <pthread.h>#define BAUDRATE     B115200#define COM  	     "/dev/ttymxc4"   //串口1设备#define FALSE 	     0#define TRUE 	     1static int fd;pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;void com_init(speed_t speed){    struct termios options;    fd = open(COM, O_RDWR | O_NOCTTY | O_NDELAY);// | O_NONBLOCK    if(fd < 0)    {         printf("open com device failure");    }    tcgetattr(fd,&options);    cfsetispeed(&options,speed);//波特率    cfsetospeed(&options,speed);    options.c_cflag |= (CLOCAL|CREAD);    options.c_lflag &= ~(ICANON | ECHO | ECHOE | ISIG);    options.c_oflag &= ~OPOST;    options.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);    tcsetattr(fd,TCSANOW,&options);}/*--------------------------------------------------------*//* modem input handler */void* receive(void * data){	char ch[1024];	int ret;  	printf("read modem\r\n");  	while (1)     	{    	ret = read(fd,ch,sizeof(ch));  //读串口0数据		if(ret > 0)		{			ch[ret] = 0;			//printf("c=%s\n",ch);			pthread_mutex_lock(&mutex);    	    write(fd,ch,strlen(ch)); //将读到的数据输出到串口0上			pthread_mutex_unlock(&mutex);		}  	}	printf("\r\n");  	printf("exit from reading modem\n");  	return NULL; }/*--------------------------------------------------------*/void* send(void * data){  	int c = '0';  	printf("send data\r\n");  	while (1)   	{        c++;		if(c > '9')		{			c = '0';		}		pthread_mutex_lock(&mutex);    	write(fd,&c,1); //循环发送字符0~9到串口0上		pthread_mutex_unlock(&mutex);		sleep(1);  	}  	printf("\r\n");  	return NULL; /* wait for child to die or it will become a zombie */}/*--------------------------------------------------------*/int main(int argc,char** argv){ 	pthread_t th_a, th_b;  	void * retval;		pthread_mutex_init(&mutex,NULL);	com_init(BAUDRATE);  	pthread_create(&th_a, NULL, receive, 0);  	pthread_create(&th_b, NULL, send, 0);        //等待子线程结束  	pthread_join(th_a, &retval);  	pthread_join(th_b, &retval);  	close(fd);  	exit(0); }